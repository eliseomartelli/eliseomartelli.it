{
  "title": "Modular applications in go",
  "excerpt": "Plugins, plugins, plugins.",
  "date": "2022-12-02T20:30:00.000Z",
  "tags": [
    "Programming",
    "Short"
  ],
  "body": {
    "raw": "\nI'm working on an unnamed application (I can't tell much about it now, but I will share more when I can) where I needed a way to load plugins dynamically based on the app's configuration.\n\nI concluded that I needed a way to \"store\" the plugins and load them based on the application configuration. It seems that the premise is akin to the \"registry\" pattern.\n\n## The registry\n\nTo have an O(1) time complexity, I decided to store plugins in a \"map\".\n\n```\n// Plugin registry.\nvar Plugins = map[string]Plugin{}\n```\n\nBut it doesn't automatically solve our problems. Golang offers an init function that gets called only when we first import a package. You can have any number of init functions inside a package (one per file, for example).\n\nSo the next idea is to use the init function to register our plugins.\n\n```\n// file plugin_name.go\npackage plugins\n\ntype PluginName struct {}\n\n...\n\nfunc init() {\n\tPlugins[\"plugin\"] = &PluginName{}\n}\n```\n\nWe already have a functioning proof-of-concept, but we can make it better!\n\n## Let it shine\n\nWe will define an interface for our plugins with some methods to manage the plugin life cycle.\n\n```\ntype Plugin interface {\n\tSetup()\n\tCleanup()\n}\n```\n\nThen I made a function to register a plugin into the register:\n\n```\n// Factory to provide a closure to get the Plugin.\ntype PluginFactory = func() Plugin\n\n// Register SHOULD BE called by the init() function of a plugin.\n// The provider will be added to the Plugin map.\nfunc Register(pluginName string, plugin PluginFactory) {\n\tif _, present := Plugins[pluginName]; present {\n\t\tlog.Fatalf(\"Plugin %s already defined.\", pluginName)\n\t}\n\tPlugins[pluginName] = plugin\n}\n```\n\nWe have to change our previous plugin to use this function:\n\n```\n// file plugin_name.go\n\nfunc init() {\n\tRegister(\"plugin\", func() Provider { return &PluginName{} })\n\n}\n```\n\n## Consuming the plugin\n\nTo use the plugins, we can, for example, iterate on a list of configured plugins, check if they're available in the map, and call the life cycle method to set them up.\n\n```\nfor _, pluginName := range configuredPlugins {\n\tif plugin, present := Plugins[pluginName]; present {\n\t\tplugin.Setup()\n\t}\n}\n```\n\nWe now have the tools to build a modular application in go.\n",
    "code": "var Component=(()=>{var g=Object.create;var a=Object.defineProperty;var s=Object.getOwnPropertyDescriptor;var d=Object.getOwnPropertyNames;var h=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var f=(i,n)=>()=>(n||i((n={exports:{}}).exports,n),n.exports),y=(i,n)=>{for(var t in n)a(i,t,{get:n[t],enumerable:!0})},o=(i,n,t,r)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let l of d(n))!m.call(i,l)&&l!==t&&a(i,l,{get:()=>n[l],enumerable:!(r=s(n,l))||r.enumerable});return i};var P=(i,n,t)=>(t=i!=null?g(h(i)):{},o(n||!i||!i.__esModule?a(t,\"default\",{value:i,enumerable:!0}):t,i)),w=i=>o(a({},\"__esModule\",{value:!0}),i);var u=f((N,c)=>{c.exports=_jsx_runtime});var _={};y(_,{default:()=>v,frontmatter:()=>b});var e=P(u()),b={title:\"Modular applications in go\",date:\"2022-12-02 21:30\",excerpt:\"Plugins, plugins, plugins.\",tags:[\"Programming\",\"Short\"]};function p(i){let n=Object.assign({p:\"p\",h2:\"h2\",pre:\"pre\",code:\"code\"},i.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)(n.p,{children:\"I'm working on an unnamed application (I can't tell much about it now, but I will share more when I can) where I needed a way to load plugins dynamically based on the app's configuration.\"}),`\n`,(0,e.jsx)(n.p,{children:'I concluded that I needed a way to \"store\" the plugins and load them based on the application configuration. It seems that the premise is akin to the \"registry\" pattern.'}),`\n`,(0,e.jsx)(n.h2,{children:\"The registry\"}),`\n`,(0,e.jsx)(n.p,{children:'To have an O(1) time complexity, I decided to store plugins in a \"map\".'}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{children:`// Plugin registry.\nvar Plugins = map[string]Plugin{}\n`})}),`\n`,(0,e.jsx)(n.p,{children:\"But it doesn't automatically solve our problems. Golang offers an init function that gets called only when we first import a package. You can have any number of init functions inside a package (one per file, for example).\"}),`\n`,(0,e.jsx)(n.p,{children:\"So the next idea is to use the init function to register our plugins.\"}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{children:`// file plugin_name.go\npackage plugins\n\ntype PluginName struct {}\n\n...\n\nfunc init() {\n\tPlugins[\"plugin\"] = &PluginName{}\n}\n`})}),`\n`,(0,e.jsx)(n.p,{children:\"We already have a functioning proof-of-concept, but we can make it better!\"}),`\n`,(0,e.jsx)(n.h2,{children:\"Let it shine\"}),`\n`,(0,e.jsx)(n.p,{children:\"We will define an interface for our plugins with some methods to manage the plugin life cycle.\"}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{children:`type Plugin interface {\n\tSetup()\n\tCleanup()\n}\n`})}),`\n`,(0,e.jsx)(n.p,{children:\"Then I made a function to register a plugin into the register:\"}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{children:`// Factory to provide a closure to get the Plugin.\ntype PluginFactory = func() Plugin\n\n// Register SHOULD BE called by the init() function of a plugin.\n// The provider will be added to the Plugin map.\nfunc Register(pluginName string, plugin PluginFactory) {\n\tif _, present := Plugins[pluginName]; present {\n\t\tlog.Fatalf(\"Plugin %s already defined.\", pluginName)\n\t}\n\tPlugins[pluginName] = plugin\n}\n`})}),`\n`,(0,e.jsx)(n.p,{children:\"We have to change our previous plugin to use this function:\"}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{children:`// file plugin_name.go\n\nfunc init() {\n\tRegister(\"plugin\", func() Provider { return &PluginName{} })\n\n}\n`})}),`\n`,(0,e.jsx)(n.h2,{children:\"Consuming the plugin\"}),`\n`,(0,e.jsx)(n.p,{children:\"To use the plugins, we can, for example, iterate on a list of configured plugins, check if they're available in the map, and call the life cycle method to set them up.\"}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{children:`for _, pluginName := range configuredPlugins {\n\tif plugin, present := Plugins[pluginName]; present {\n\t\tplugin.Setup()\n\t}\n}\n`})}),`\n`,(0,e.jsx)(n.p,{children:\"We now have the tools to build a modular application in go.\"})]})}function x(i={}){let{wrapper:n}=i.components||{};return n?(0,e.jsx)(n,Object.assign({},i,{children:(0,e.jsx)(p,i)})):p(i)}var v=x;return w(_);})();\n;return Component;"
  },
  "_id": "blog/02-12-2022-gomodular.md",
  "_raw": {
    "sourceFilePath": "blog/02-12-2022-gomodular.md",
    "sourceFileName": "02-12-2022-gomodular.md",
    "sourceFileDir": "blog",
    "contentType": "markdown",
    "flattenedPath": "blog/02-12-2022-gomodular"
  },
  "type": "Post",
  "url": "blog/02-12-2022-gomodular",
  "timeToRead": "2"
}