{
  "title": "Configuring Nebula, a simple overlay networking tool",
  "excerpt": "Overlay networking that scaaaaaaaaaales",
  "date": "2020-05-01T00:00:00.000Z",
  "tags": [
    "Network"
  ],
  "body": {
    "raw": "\n![](https://cdn.spacetelescope.org/archives/images/screen/opo9544b.jpg)\n\nVPNs are one of the preferred ways to tie-up multiple servers (and clients) together, but their nature becomes a **bottleneck** when the infrastructure to _link_ becomes larger.\\\nA solution to this problem comes in the form of a software defined network **(SDN)**.\n\n**[Nebula](https://github.com/slackhq/nebula)** (from SlackHQ) addresses this problem by providing software that helps you build a point-to-point network between devices that can be situated (almost) anywhere in the world!\n\nThe communication between devices is encrypted using the [Noise Protocol Framework](https://noiseprotocol.org/), the same used by Signal.\n\nAnd you know what's great? Nebula is completely **open source!**\n\n## Nebula Vocabolary\n\nNebula's vocabolary is not so different from normal networking, you should only get accostumed to two terms:\n\n- lighthouse;\n- node.\n\n**Lighthouse** is the term used by Nebula to address **nodes** that are publicly routable.\\\nA node connects first to the **lighthouse**, then it discovers the most efficent path to reach other nodes on the network.\n\n## Configuring Nebula\n\nLet's get to the fun part!\n\nAs stated earlier, to run a Nebula Lighthouse you need a machine with a **publicly routable** IP address, if you don't have one, a little 5\\$ Droplet on [DigitalOcean](https://m.do.co/c/33e2f0a1e231) will do just fine.\\\nThis guide will show you how to run Nebula **as a regular user**, in constrast with the official documentation that assumes you will run Nebula as the root user.\n\nOn the machines you'd like to attach to Nebula, you need to **download the binary** from the release page on GitHub and then extract it using _tar_.\n\n```bash\n$ curl -OL https://github.com/slackhq/nebula/releases/download/v1.2.0/nebula-linux-amd64.tar.gz\n$ tar xzvf nebula-linux-amd64.tar.gz\n```\n\nNow you need to **move the Nebula binary** to /usr/bin/ and set the right permissions.\\\nYou can do it manually or you can use the _[install](https://man.cx/install)_ command.\n\n```bash\n# install ./nebula /usr/bin\n```\n\nSince we don't want to run Nebula as root, it's the right time to add a _system_ user (so it's **hidden** from your login manager) for Nebula.\\\nThis new user doesn't need a _home_ directory, so we're instructing the _useradd_ command to not create one.\n\n```bash\n#Â useradd --system --no-create-home nebula\n```\n\nFollowing the [Filesystem Hierarchy Standard](https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard) that states that configuration files should reside in the /etc directory, we're going to **create the directories** to store configuration files and certificates that are related to Nebula.\n\n```bash\n# mkdir /etc/nebula\n# mkdir /etc/nebula/certs\n```\n\nTo instantiate a Nebula network you have to **generate a Nebula Certificate authority**, preferably on another host so you can keep your private key secure. Remember to copy the certificate to your hosts!\n\n```bash\n$ ./nebula-cert ca -name \"My really cool organization\"\n$ scp ca.crt user@<hostname>:/etc/nebula/certs\n```\n\nMake sure to **keep the ca.key file in a safe place**, you will need it if you want to add other hosts to your network.\n\n**Generate a keypair** for each host you'd like to connect to your Nebula network and copy the pair to your Nebula's hosts:\n\n```bash\n$ ./nebula-cert sign -name \"mylighthouse\" -ip \"192.168.100.1/24\"\n$ scp mylighthouse.crt user@<hostname>:/etc/nebula/certs\n$ scp mylighthouse.key user@<hostname>:/etc/nebula/certs\n```\n\nIt's time to configure Nebula!\\\n**Create a configuration file** inside the previously created directory and open it with your text editor of choice. I've deviced to put my configuration in /etc/nebula/config.yml.\nThe configuration will look a bit different depending by the node, for example, my Lighthouse node is sporting this configuration:\n\n```yaml\npki:\n  ca: /etc/nebula/certs/ca.crt\n  cert: /etc/nebula/certs/mylighthouse.crt\n  key: /etc/nebula/certs/mylighthouse.key\n\nlighthouse:\n  am_lighthouse: true\n\nlisten:\n  host: 0.0.0.0\n  port: 4242\n\npunchy:\n  punch: true\n\ntun:\n  dev: nebula1\n  drop_local_broadcast: false\n  drop_multicast: false\n  tx_queue: 500\n  mtu: 1300\n  routes:\n  unsafe_routes:\n\nfirewall:\n  conntrack:\n    tcp_timeout: 120h\n    udp_timeout: 3m\n    default_timeout: 10m\n    max_connections: 100000\n\n  outbound:\n    # Allow all outbound traffic from this node\n    - port: any\n      proto: any\n      host: any\n\n  inbound:\n    # Allow icmp between any nebula hosts\n    - port: any\n      proto: icmp\n      host: any\n```\n\nOn my other nodes, the configuration looks something like this:\n\n```yaml\npki:\n  ca: /etc/nebula/certs/ca.crt\n  cert: /etc/nebula/certs/mynode.crt\n  key: /etc/nebula/certs/mynode.key\n\nstatic_host_map:\n  \"192.168.100.1\": [\"<lighthouse_public_ip>:4242\"]\n\nlighthouse:\n  hosts:\n    - \"192.168.100.1\"\n\npunchy:\n  punch: true\n\ntun:\n  dev: nebula1\n  drop_local_broadcast: false\n  drop_multicast: false\n  tx_queue: 500\n  mtu: 1300\n  routes:\n  unsafe_routes:\n\nfirewall:\n  conntrack:\n    tcp_timeout: 120h\n    udp_timeout: 3m\n    default_timeout: 10m\n    max_connections: 100000\n\n  outbound:\n    # Allow all outbound traffic from this node\n    - port: any\n      proto: any\n      host: any\n\n  inbound:\n    # Allow icmp between any nebula hosts\n    - port: any\n      proto: icmp\n      host: any\n```\n\nNote that **nodes** need to **define their \"Lighthouse\".**\n\nTo make our \"nebula\" user the owner of the /etc/nebula directory, we have to change the ownership of it. We should also change the permissions of the certificats to something less permissive.\n\n```bash\n# chown -R nebula:nebula /etc/nebula\n# chmod 600 /etc/nebula/certs/*\n```\n\nWe're almost done! The second-last thing to do is to add the _NET_CAP_ADMIN_ capability to the Nebula binary since it needs to be able to create a new interface on the system.\n\n```bash\n# setcap cap_net_admin=+pe /usr/bin/nebula\n```\n\nFor our last step, we run Nebula as the nebula user on our hosts.\n\n```bash\n# su nebula\n$ nebula -config /etc/nebula/config.yml\n```\n\nTo **test Nebula** open a new shell and try to ping another machine on the Nebula network, _it's almost magical_.\n\n## Nebula as a Systemd unit\n\nA natural step to take after you've tested Nebula is to **run it as a service** so you don't need to start it manually each time you need it. Well, nothing could be simpler!\\\nYou just have to create and edit a Systemd unit. An example can be found below:\n\n_/etc/systemd/system/nebula.service_\n\n```\n[Unit]\nDescription=Nebula Service\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=always\nRestartSec=1\nUser=nebula\nExecStart=/usr/bin/nebula -config /etc/nebula/config.yml\n\n[Install]\nWantedBy=multi-user.target\n```\n\nNote that this Systemd unit runs Nebula with the \"nebula\" user and starts just after reaching the network target.\n\nNow you need to **reload** configuration files for the daemons on your system so Systemd can pick-up the new unit:\n\n```bash\n# systemctl daemon-reload\n```\n\nYou can now **enable** the Nebula service so it starts automatically after a reboot. If you're not going to reboot, remember to **start** the service manually. ðŸ˜‰\n\n```bash\n#Â systemctl enable nebula.service\n#Â systemctl start nebula.service\n```\n\n---\n\n#### Update: Launchd on macOS\n\nIf you want to run Nebula as a daemon on **macOS**, create and edit a launchd plist file as follows:\n\n_/Library/LaunchDaemons/com.nebula.plist_\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n  <dict>\n      <key>Label</key>\n      <string>/usr/local/bin/nebula</string>\n      <key>LaunchOnlyOnce</key>\n      <true/>\n      <key>ProgramArguments</key>\n      <array>\n          <string>/usr/local/bin/nebula</string>\n          <string>-config</string>\n          <string>/etc/nebula/config.yml</string>\n      </array>\n      <key>RunAtLoad</key>\n      <true/>\n  </dict>\n</plist>\n```\n\nRemember to load this new daemon:\n\n```bash\n# sudo launchctl load /Library/LaunchDaemons/com.nebula.plist\n```\n\nOh, nice to see you here!  \nIf you've reached the end of this post you can now enjoy your _freshly baked_ SDN!\n\n---\n\n_Disclosure: this post contains one (or more) affiliate link. If you buy something through one of those links you won't pay anything more but I'll get a small commission that helps me mantaining this blog._\n",
    "code": "var Component=(()=>{var u=Object.create;var o=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var b=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),y=(t,e)=>{for(var r in e)o(t,r,{get:e[r],enumerable:!0})},l=(t,e,r,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of m(e))!g.call(t,a)&&a!==r&&o(t,a,{get:()=>e[a],enumerable:!(i=d(e,a))||i.enumerable});return t};var f=(t,e,r)=>(r=t!=null?u(p(t)):{},l(e||!t||!t.__esModule?o(r,\"default\",{value:t,enumerable:!0}):r,t)),w=t=>l(o({},\"__esModule\",{value:!0}),t);var c=b((S,s)=>{s.exports=_jsx_runtime});var _={};y(_,{default:()=>v,frontmatter:()=>k});var n=f(c()),k={title:\"Configuring Nebula, a simple overlay networking tool\",date:\"2020-05-01\",excerpt:\"Overlay networking that scaaaaaaaaaales\",tags:[\"Network\"]};function h(t){let e=Object.assign({p:\"p\",img:\"img\",strong:\"strong\",em:\"em\",br:\"br\",a:\"a\",h2:\"h2\",ul:\"ul\",li:\"li\",pre:\"pre\",code:\"code\",hr:\"hr\",h4:\"h4\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"https://cdn.spacetelescope.org/archives/images/screen/opo9544b.jpg\",alt:\"\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"VPNs are one of the preferred ways to tie-up multiple servers (and clients) together, but their nature becomes a \",(0,n.jsx)(e.strong,{children:\"bottleneck\"}),\" when the infrastructure to \",(0,n.jsx)(e.em,{children:\"link\"}),\" becomes larger.\",(0,n.jsx)(e.br,{}),`\n`,\"A solution to this problem comes in the form of a software defined network \",(0,n.jsx)(e.strong,{children:\"(SDN)\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:(0,n.jsx)(e.a,{href:\"https://github.com/slackhq/nebula\",children:\"Nebula\"})}),\" (from SlackHQ) addresses this problem by providing software that helps you build a point-to-point network between devices that can be situated (almost) anywhere in the world!\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The communication between devices is encrypted using the \",(0,n.jsx)(e.a,{href:\"https://noiseprotocol.org/\",children:\"Noise Protocol Framework\"}),\", the same used by Signal.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"And you know what's great? Nebula is completely \",(0,n.jsx)(e.strong,{children:\"open source!\"})]}),`\n`,(0,n.jsx)(e.h2,{children:\"Nebula Vocabolary\"}),`\n`,(0,n.jsx)(e.p,{children:\"Nebula's vocabolary is not so different from normal networking, you should only get accostumed to two terms:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"lighthouse;\"}),`\n`,(0,n.jsx)(e.li,{children:\"node.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Lighthouse\"}),\" is the term used by Nebula to address \",(0,n.jsx)(e.strong,{children:\"nodes\"}),\" that are publicly routable.\",(0,n.jsx)(e.br,{}),`\n`,\"A node connects first to the \",(0,n.jsx)(e.strong,{children:\"lighthouse\"}),\", then it discovers the most efficent path to reach other nodes on the network.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Configuring Nebula\"}),`\n`,(0,n.jsx)(e.p,{children:\"Let's get to the fun part!\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"As stated earlier, to run a Nebula Lighthouse you need a machine with a \",(0,n.jsx)(e.strong,{children:\"publicly routable\"}),\" IP address, if you don't have one, a little 5$ Droplet on \",(0,n.jsx)(e.a,{href:\"https://m.do.co/c/33e2f0a1e231\",children:\"DigitalOcean\"}),\" will do just fine.\",(0,n.jsx)(e.br,{}),`\n`,\"This guide will show you how to run Nebula \",(0,n.jsx)(e.strong,{children:\"as a regular user\"}),\", in constrast with the official documentation that assumes you will run Nebula as the root user.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"On the machines you'd like to attach to Nebula, you need to \",(0,n.jsx)(e.strong,{children:\"download the binary\"}),\" from the release page on GitHub and then extract it using \",(0,n.jsx)(e.em,{children:\"tar\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-bash\",children:`$ curl -OL https://github.com/slackhq/nebula/releases/download/v1.2.0/nebula-linux-amd64.tar.gz\n$ tar xzvf nebula-linux-amd64.tar.gz\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Now you need to \",(0,n.jsx)(e.strong,{children:\"move the Nebula binary\"}),\" to /usr/bin/ and set the right permissions.\",(0,n.jsx)(e.br,{}),`\n`,\"You can do it manually or you can use the \",(0,n.jsx)(e.em,{children:(0,n.jsx)(e.a,{href:\"https://man.cx/install\",children:\"install\"})}),\" command.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-bash\",children:`# install ./nebula /usr/bin\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Since we don't want to run Nebula as root, it's the right time to add a \",(0,n.jsx)(e.em,{children:\"system\"}),\" user (so it's \",(0,n.jsx)(e.strong,{children:\"hidden\"}),\" from your login manager) for Nebula.\",(0,n.jsx)(e.br,{}),`\n`,\"This new user doesn't need a \",(0,n.jsx)(e.em,{children:\"home\"}),\" directory, so we're instructing the \",(0,n.jsx)(e.em,{children:\"useradd\"}),\" command to not create one.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-bash\",children:`#\\xA0useradd --system --no-create-home nebula\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Following the \",(0,n.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard\",children:\"Filesystem Hierarchy Standard\"}),\" that states that configuration files should reside in the /etc directory, we're going to \",(0,n.jsx)(e.strong,{children:\"create the directories\"}),\" to store configuration files and certificates that are related to Nebula.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-bash\",children:`# mkdir /etc/nebula\n# mkdir /etc/nebula/certs\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"To instantiate a Nebula network you have to \",(0,n.jsx)(e.strong,{children:\"generate a Nebula Certificate authority\"}),\", preferably on another host so you can keep your private key secure. Remember to copy the certificate to your hosts!\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-bash\",children:`$ ./nebula-cert ca -name \"My really cool organization\"\n$ scp ca.crt user@<hostname>:/etc/nebula/certs\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Make sure to \",(0,n.jsx)(e.strong,{children:\"keep the ca.key file in a safe place\"}),\", you will need it if you want to add other hosts to your network.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Generate a keypair\"}),\" for each host you'd like to connect to your Nebula network and copy the pair to your Nebula's hosts:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-bash\",children:`$ ./nebula-cert sign -name \"mylighthouse\" -ip \"192.168.100.1/24\"\n$ scp mylighthouse.crt user@<hostname>:/etc/nebula/certs\n$ scp mylighthouse.key user@<hostname>:/etc/nebula/certs\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"It's time to configure Nebula!\",(0,n.jsx)(e.br,{}),`\n`,(0,n.jsx)(e.strong,{children:\"Create a configuration file\"}),` inside the previously created directory and open it with your text editor of choice. I've deviced to put my configuration in /etc/nebula/config.yml.\nThe configuration will look a bit different depending by the node, for example, my Lighthouse node is sporting this configuration:`]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`pki:\n  ca: /etc/nebula/certs/ca.crt\n  cert: /etc/nebula/certs/mylighthouse.crt\n  key: /etc/nebula/certs/mylighthouse.key\n\nlighthouse:\n  am_lighthouse: true\n\nlisten:\n  host: 0.0.0.0\n  port: 4242\n\npunchy:\n  punch: true\n\ntun:\n  dev: nebula1\n  drop_local_broadcast: false\n  drop_multicast: false\n  tx_queue: 500\n  mtu: 1300\n  routes:\n  unsafe_routes:\n\nfirewall:\n  conntrack:\n    tcp_timeout: 120h\n    udp_timeout: 3m\n    default_timeout: 10m\n    max_connections: 100000\n\n  outbound:\n    # Allow all outbound traffic from this node\n    - port: any\n      proto: any\n      host: any\n\n  inbound:\n    # Allow icmp between any nebula hosts\n    - port: any\n      proto: icmp\n      host: any\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"On my other nodes, the configuration looks something like this:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`pki:\n  ca: /etc/nebula/certs/ca.crt\n  cert: /etc/nebula/certs/mynode.crt\n  key: /etc/nebula/certs/mynode.key\n\nstatic_host_map:\n  \"192.168.100.1\": [\"<lighthouse_public_ip>:4242\"]\n\nlighthouse:\n  hosts:\n    - \"192.168.100.1\"\n\npunchy:\n  punch: true\n\ntun:\n  dev: nebula1\n  drop_local_broadcast: false\n  drop_multicast: false\n  tx_queue: 500\n  mtu: 1300\n  routes:\n  unsafe_routes:\n\nfirewall:\n  conntrack:\n    tcp_timeout: 120h\n    udp_timeout: 3m\n    default_timeout: 10m\n    max_connections: 100000\n\n  outbound:\n    # Allow all outbound traffic from this node\n    - port: any\n      proto: any\n      host: any\n\n  inbound:\n    # Allow icmp between any nebula hosts\n    - port: any\n      proto: icmp\n      host: any\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Note that \",(0,n.jsx)(e.strong,{children:\"nodes\"}),\" need to \",(0,n.jsx)(e.strong,{children:'define their \"Lighthouse\".'})]}),`\n`,(0,n.jsx)(e.p,{children:'To make our \"nebula\" user the owner of the /etc/nebula directory, we have to change the ownership of it. We should also change the permissions of the certificats to something less permissive.'}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-bash\",children:`# chown -R nebula:nebula /etc/nebula\n# chmod 600 /etc/nebula/certs/*\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"We're almost done! The second-last thing to do is to add the \",(0,n.jsx)(e.em,{children:\"NET_CAP_ADMIN\"}),\" capability to the Nebula binary since it needs to be able to create a new interface on the system.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-bash\",children:`# setcap cap_net_admin=+pe /usr/bin/nebula\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"For our last step, we run Nebula as the nebula user on our hosts.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-bash\",children:`# su nebula\n$ nebula -config /etc/nebula/config.yml\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"To \",(0,n.jsx)(e.strong,{children:\"test Nebula\"}),\" open a new shell and try to ping another machine on the Nebula network, \",(0,n.jsx)(e.em,{children:\"it's almost magical\"}),\".\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Nebula as a Systemd unit\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"A natural step to take after you've tested Nebula is to \",(0,n.jsx)(e.strong,{children:\"run it as a service\"}),\" so you don't need to start it manually each time you need it. Well, nothing could be simpler!\",(0,n.jsx)(e.br,{}),`\n`,\"You just have to create and edit a Systemd unit. An example can be found below:\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.em,{children:\"/etc/systemd/system/nebula.service\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`[Unit]\nDescription=Nebula Service\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=always\nRestartSec=1\nUser=nebula\nExecStart=/usr/bin/nebula -config /etc/nebula/config.yml\n\n[Install]\nWantedBy=multi-user.target\n`})}),`\n`,(0,n.jsx)(e.p,{children:'Note that this Systemd unit runs Nebula with the \"nebula\" user and starts just after reaching the network target.'}),`\n`,(0,n.jsxs)(e.p,{children:[\"Now you need to \",(0,n.jsx)(e.strong,{children:\"reload\"}),\" configuration files for the daemons on your system so Systemd can pick-up the new unit:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-bash\",children:`# systemctl daemon-reload\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"You can now \",(0,n.jsx)(e.strong,{children:\"enable\"}),\" the Nebula service so it starts automatically after a reboot. If you're not going to reboot, remember to \",(0,n.jsx)(e.strong,{children:\"start\"}),\" the service manually. \\u{1F609}\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-bash\",children:`#\\xA0systemctl enable nebula.service\n#\\xA0systemctl start nebula.service\n`})}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.h4,{children:\"Update: Launchd on macOS\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"If you want to run Nebula as a daemon on \",(0,n.jsx)(e.strong,{children:\"macOS\"}),\", create and edit a launchd plist file as follows:\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.em,{children:\"/Library/LaunchDaemons/com.nebula.plist\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-xml\",children:`<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n  <dict>\n      <key>Label</key>\n      <string>/usr/local/bin/nebula</string>\n      <key>LaunchOnlyOnce</key>\n      <true/>\n      <key>ProgramArguments</key>\n      <array>\n          <string>/usr/local/bin/nebula</string>\n          <string>-config</string>\n          <string>/etc/nebula/config.yml</string>\n      </array>\n      <key>RunAtLoad</key>\n      <true/>\n  </dict>\n</plist>\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Remember to load this new daemon:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-bash\",children:`# sudo launchctl load /Library/LaunchDaemons/com.nebula.plist\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Oh, nice to see you here!\",(0,n.jsx)(e.br,{}),`\n`,\"If you've reached the end of this post you can now enjoy your \",(0,n.jsx)(e.em,{children:\"freshly baked\"}),\" SDN!\"]}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.em,{children:\"Disclosure: this post contains one (or more) affiliate link. If you buy something through one of those links you won't pay anything more but I'll get a small commission that helps me mantaining this blog.\"})})]})}function N(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(h,t)})):h(t)}var v=N;return w(_);})();\n;return Component;"
  },
  "_id": "blog/nebula.md",
  "_raw": {
    "sourceFilePath": "blog/nebula.md",
    "sourceFileName": "nebula.md",
    "sourceFileDir": "blog",
    "contentType": "markdown",
    "flattenedPath": "blog/nebula"
  },
  "type": "Post",
  "url": "blog/nebula",
  "timeToRead": "6"
}