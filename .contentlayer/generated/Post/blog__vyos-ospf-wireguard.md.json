{
  "title": "OSPF over Wireguard with VyOS",
  "excerpt": "Avoiding static routes because I'm lazy and I wanted to lab a bit",
  "date": "2022-09-29T00:00:00.000Z",
  "tags": [
    "Network"
  ],
  "body": {
    "raw": "\nMy home network is getting another friend, and I wanted to share the experience of setting everything up with you.  \nI already had a site-to-site VPN setup using Wireguard between three sites, but there was a little problem: I had to set up static routes between these sites. (And maintaining static routes is a big chore, a task no network administrator would like to be involved in).\n\n<img src=\"/posts/vyos-ospf-wireguard/cover.svg\" alt=\"Three routers connected over WAN\" className=\"\"/>\n\n## Meet OSPF\n\nOSPF is a routing protocol that operates inside an autonomous system (AS). OSPF is a link-state protocol that means that every router in the network knows the entire topology of the network. Each router calculates the best next hops from itself to every other possible destination. The list of best next-hops gets appended to the routing table.\n\nOSPF networks are broken apart into _areas_. Area 0 (also called backbone area) is a particular type of OSPF area to which all other areas are connected. Routers in an area form adjacencies when they detect each other.\n\nOSPF supports different operation modes, depending on what interface it is running on. The default operation mode is _broadcast_. Wireguard is an L3 point-to-point tunnel, which means we can't use broadcast. We have to resort to using the [\"point-to-point\"](https://datatracker.ietf.org/doc/html/rfc2328#page-130) operation mode.\n\nIt looks like the perfect candidate for our purposes. Another option we could use is RIP which has some advantages over OSPF in terms of resource utilization on the machine(s) running it but consumes more bandwidth since it transmits the entire routing table every 30 seconds. OSPF, on the other hand, sends only the entries of the routing table that changed.\n\n## Network topology\n\nThe network has three routers in three different sites, connected with Wireguard over the internet. Each router connects to several networks. Only a subset of these networks should be advertised to other routers.\n\n![Network diagram](/posts/vyos-ospf-wireguard/netdiag1.svg)\n\n## Preparation\n\nFirst things firsts, we have to establish the needed Wireguard tunnels.\nWe are adding an interface for each router pair for a specific reason: we need to set `AllowedIPs` to `0.0.0.0/0` for every peer. Wireguard [doesn't support](https://lists.zx2c4.com/pipermail/wireguard/2018-December/003704.html) having the same `AllowedIPs` on multiple peers on the same interface.\n\nQuoting Wireguard's homepage:\n\n> ...when sending packets, the list of allowed IPs behaves as a sort of routing table, and when receiving packets, the list of allowed IPs behaves as a sort of access control list....\n\nSince we have three routers, we have to configure six interfaces, two for each router, spanning three point-to-point subnets.\n\nAs a first step, we decide on our subnets respecting [RFC1918](https://datatracker.ietf.org/doc/html/rfc1818). In my case, I can start playing with `192.168.69.0/24`.\n\n```\n                                             V\n192.168. 69.  0    11000000.10101000.01000101.00000000\n\n# Let's make 3 /30 subnets\n                                                    V\n192.168. 69.  0    11000000.10101000.01000101.000000 00\n192.168. 69.  4    11000000.10101000.01000101.000001 00\n192.168. 69.  8    11000000.10101000.01000101.000010 00\n```\n\nWe can now start configuring our VyOS routers (I'm assuming you already have SSH or console access to the router and a WAN connection).\n\nSSH to rtr-01:\n\n```bash\nrtr-01 $ generate wireguard named-keypairs link_01_to_02\nrtr-01 $ generate wireguard named-keypairs link_01_to_03\n\n# Take note of the pubkeys\nrtr-01 $ show wireguard keypairs pubkey link_01_to_02\nrtr-01 $ show wireguard keypairs pubkey link_01_to_03\n\nrtr-01 $ configure\n\nrtr-01 # edit interfaces wireguard wg01\nrtr-01 # set address 192.168.69.1/30\nrtr-01 # set private-key link_01_to_02\nrtr-01 # set port 7878\nrtr-01 # set description link_01_to_02\nrtr-01 # set peer rtr-02 allowed-ips 0.0.0.0/0\nrtr-01 # set peer rtr-02 pubkey <link_02_to_01 pubkey>\n\nrtr-01 # top\n\nrtr-01 # edit interfaces wireguard wg02\nrtr-01 # set address 192.168.69.5/30\nrtr-01 # set private-key link_01_to_03\nrtr-01 # set port 7879\nrtr-01 # set description link_01_to_03\nrtr-01 # set peer rtr-02 allowed-ips 0.0.0.0/0\nrtr-01 # set peer rtr-02 pubkey <link_03_to_01 pubkey>\n\nrtr-01 # commit; save; exit\n```\n\nNow SSH to the other routers and apply the \"same\" configuration, changing addresses, ports and keys. To streamline the task, you can use your preferred automation tool. I'm using [Ansible](https://www.ansible.com).\n\nDon't forget to allow the used ports on your firewall configuration.\n\nAt this time, you should be able to ping other routers connected at the other end of the tunnels. If everything is working, we can get to the OSPF configuration.\n\n## A _sprinkle_ of OSPF\n\nAs we stated, we have to configure our interfaces to run OSPF In point-to-point mode. Get a shell onto your router and:\n\n```\nrtr-01 $ configure\nrtr-01 # edit interfaces wireguard wg01\nrtr-01 # set ip ospf network point-to-point\nrtr-01 # top\nrtr-01 # copy interfaces wireguard wg01 ip to interfaces wireguard wg02 ip\nrtr-01 # commit; save; exit\n```\n\nFollow the same steps on your other routers. Now we are at the fun part!\n\nWe are adding the 0.0.0.0 area on every router, telling the OSPF daemon which point-to-point networks are part of this area, and telling what routes the router should redistribute to every other router.\n\nYou know the drill, SSH to your favorite router first, and tell it what to do! Then, configure the other routers like this first one.\n\n```\nrtr-01 $ configure\nrtr-01 # edit protocols ospf area 0.0.0.0\nrtr-01 # set network 192.168.69.0/30\nrtr-01 # set network 192.168.69.4/30\nrtr-01 # set network 192.168.69.8/30\nrtr-01 # set redistribute connected\nrtr-01 # commit; save; exit\n```\n\nI'm not covering how to set up your firewall here since your configuration might be different than mine (I'm using zone-based firewall policies). Remember to accept traffic (from and to) the previously defined Wireguard interfaces.\n\n## Let's check if everything is in its place\n\nAt this point, everything should be working.  \nLet's check:\n\n1. if the neighboring relationships are getting formed;\n2. if the link-state database is getting populated;\n3. if routes are getting injected into the routing table.\n\n### Neighboring relationships\n\n```\nrtr-01 $ show ip ospf neighbor\n```\n\n### Link-state database\n\n```\nrtr-01 $ show ip ospf database\n```\n\n### Routes\n\n```\nrtr-01 $ show ip route ospf\n```\n\n## Filtering routes\n\nWe can use a routing policy to filter the redistributed routes from our routers.\nA route map allows us to match a network or an interface (or an as-path, an extcommunity, a metric, a peer, a community, etc.).\nFor our purposes, we will permit the redistribution of networks attached to some interfaces.\n\nLet's create a new policy:\n\n```\nrtr-01 $ configure\nrtr-01 # edit policy route-map FilteredRoutes\nrtr-01 # set rule 10 action permit\nrtr-01 # set rule 10 match interface eth1\nrtr-01 # commit\n```\n\nAnd now apply this policy to the redistribution configuration of the OSPF daemon:\n\n```\nrtr-01 # top\nrtr-01 # edit protocols ospf redistribute connected\nrtr-01 # set route-map FilteredRoutes\nrtr-01 # commit; save; exit\n```\n\n## Bonus: (s)NAT\n\nLet's say you want to access a web server that sits in a network redistributed by `rtr-02` from a client in a network attached to `rtr-01`, but we configured this router to don't redistribute that network.\nIn this case, SNAT is our friend. We are going to translate the source address of our client to the address of the interface connected to `rtr-02`.\n\n![Network diagram](/posts/vyos-ospf-wireguard/netdiag2.svg)\n\nLet's add this NAT rule to `rtr-01`.\n\n```\nrtr-01 $ configure\nrtr-01 # edit nat source\nrtr-01 # set rule 100 outbound-interface wg01\nrtr-01 # set rule 100 source address 192.168.16.0/24 # Change with your network.\nrtr-01 # commit; save; exit\n```\n\n## Final checks\n\n### Neighboring relationships\n\n```\nrtr-01 $ show ip ospf neighbor\n```\n\n### Link-state database\n\n```\nrtr-01 $ show ip ospf database\n```\n\n### Routes\n\n```\nrtr-01 $ show ip route ospf\n```\n\nYou can see that the link state database and, consequently, the routing table are leaner than before since we have fewer routes advertised between our routers.\n\n## Conclusion\n\n![An image of Adele the singer, with \"Hello from your OSPF neighbor\" superimposed](/posts/vyos-ospf-wireguard/hello-from-your-ospf-neighbor.jpg)\n\nAnd we are golden!  \nEnjoy your brand new site-to-site VPN, and forget about adding static routes manually. OSPF will take care of that for you.\n",
    "code": "var Component=(()=>{var l=Object.create;var i=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var w=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),m=(r,e)=>{for(var n in e)i(r,n,{get:e[n],enumerable:!0})},a=(r,e,n,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of u(e))!f.call(r,o)&&o!==n&&i(r,o,{get:()=>e[o],enumerable:!(s=p(e,o))||s.enumerable});return r};var b=(r,e,n)=>(n=r!=null?l(g(r)):{},a(e||!r||!r.__esModule?i(n,\"default\",{value:r,enumerable:!0}):n,r)),k=r=>a(i({},\"__esModule\",{value:!0}),r);var c=w((P,h)=>{h.exports=_jsx_runtime});var S={};m(S,{default:()=>_,frontmatter:()=>y});var t=b(c()),y={title:\"OSPF over Wireguard with VyOS\",date:\"2022-09-29\",excerpt:\"Avoiding static routes because I'm lazy and I wanted to lab a bit\",previewImgUrl:\"https://eliseomartelli.it/posts/vyos-ospf-wireguard/social.png\",tags:[\"Network\"]};function d(r){let e=Object.assign({p:\"p\",br:\"br\",h2:\"h2\",em:\"em\",a:\"a\",img:\"img\",code:\"code\",blockquote:\"blockquote\",pre:\"pre\",ol:\"ol\",li:\"li\",h3:\"h3\"},r.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"My home network is getting another friend, and I wanted to share the experience of setting everything up with you.\",(0,t.jsx)(e.br,{}),`\n`,\"I already had a site-to-site VPN setup using Wireguard between three sites, but there was a little problem: I had to set up static routes between these sites. (And maintaining static routes is a big chore, a task no network administrator would like to be involved in).\"]}),`\n`,(0,t.jsx)(\"img\",{src:\"/posts/vyos-ospf-wireguard/cover.svg\",alt:\"Three routers connected over WAN\",className:\"\"}),`\n`,(0,t.jsx)(e.h2,{children:\"Meet OSPF\"}),`\n`,(0,t.jsx)(e.p,{children:\"OSPF is a routing protocol that operates inside an autonomous system (AS). OSPF is a link-state protocol that means that every router in the network knows the entire topology of the network. Each router calculates the best next hops from itself to every other possible destination. The list of best next-hops gets appended to the routing table.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"OSPF networks are broken apart into \",(0,t.jsx)(e.em,{children:\"areas\"}),\". Area 0 (also called backbone area) is a particular type of OSPF area to which all other areas are connected. Routers in an area form adjacencies when they detect each other.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"OSPF supports different operation modes, depending on what interface it is running on. The default operation mode is \",(0,t.jsx)(e.em,{children:\"broadcast\"}),\". Wireguard is an L3 point-to-point tunnel, which means we can't use broadcast. We have to resort to using the \",(0,t.jsx)(e.a,{href:\"https://datatracker.ietf.org/doc/html/rfc2328#page-130\",children:'\"point-to-point\"'}),\" operation mode.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"It looks like the perfect candidate for our purposes. Another option we could use is RIP which has some advantages over OSPF in terms of resource utilization on the machine(s) running it but consumes more bandwidth since it transmits the entire routing table every 30 seconds. OSPF, on the other hand, sends only the entries of the routing table that changed.\"}),`\n`,(0,t.jsx)(e.h2,{children:\"Network topology\"}),`\n`,(0,t.jsx)(e.p,{children:\"The network has three routers in three different sites, connected with Wireguard over the internet. Each router connects to several networks. Only a subset of these networks should be advertised to other routers.\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/posts/vyos-ospf-wireguard/netdiag1.svg\",alt:\"Network diagram\"})}),`\n`,(0,t.jsx)(e.h2,{children:\"Preparation\"}),`\n`,(0,t.jsxs)(e.p,{children:[`First things firsts, we have to establish the needed Wireguard tunnels.\nWe are adding an interface for each router pair for a specific reason: we need to set `,(0,t.jsx)(e.code,{children:\"AllowedIPs\"}),\" to \",(0,t.jsx)(e.code,{children:\"0.0.0.0/0\"}),\" for every peer. Wireguard \",(0,t.jsx)(e.a,{href:\"https://lists.zx2c4.com/pipermail/wireguard/2018-December/003704.html\",children:\"doesn't support\"}),\" having the same \",(0,t.jsx)(e.code,{children:\"AllowedIPs\"}),\" on multiple peers on the same interface.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Quoting Wireguard's homepage:\"}),`\n`,(0,t.jsxs)(e.blockquote,{children:[`\n`,(0,t.jsx)(e.p,{children:\"...when sending packets, the list of allowed IPs behaves as a sort of routing table, and when receiving packets, the list of allowed IPs behaves as a sort of access control list....\"}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"Since we have three routers, we have to configure six interfaces, two for each router, spanning three point-to-point subnets.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"As a first step, we decide on our subnets respecting \",(0,t.jsx)(e.a,{href:\"https://datatracker.ietf.org/doc/html/rfc1818\",children:\"RFC1918\"}),\". In my case, I can start playing with \",(0,t.jsx)(e.code,{children:\"192.168.69.0/24\"}),\".\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`                                             V\n192.168. 69.  0    11000000.10101000.01000101.00000000\n\n# Let's make 3 /30 subnets\n                                                    V\n192.168. 69.  0    11000000.10101000.01000101.000000 00\n192.168. 69.  4    11000000.10101000.01000101.000001 00\n192.168. 69.  8    11000000.10101000.01000101.000010 00\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"We can now start configuring our VyOS routers (I'm assuming you already have SSH or console access to the router and a WAN connection).\"}),`\n`,(0,t.jsx)(e.p,{children:\"SSH to rtr-01:\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-bash\",children:`rtr-01 $ generate wireguard named-keypairs link_01_to_02\nrtr-01 $ generate wireguard named-keypairs link_01_to_03\n\n# Take note of the pubkeys\nrtr-01 $ show wireguard keypairs pubkey link_01_to_02\nrtr-01 $ show wireguard keypairs pubkey link_01_to_03\n\nrtr-01 $ configure\n\nrtr-01 # edit interfaces wireguard wg01\nrtr-01 # set address 192.168.69.1/30\nrtr-01 # set private-key link_01_to_02\nrtr-01 # set port 7878\nrtr-01 # set description link_01_to_02\nrtr-01 # set peer rtr-02 allowed-ips 0.0.0.0/0\nrtr-01 # set peer rtr-02 pubkey <link_02_to_01 pubkey>\n\nrtr-01 # top\n\nrtr-01 # edit interfaces wireguard wg02\nrtr-01 # set address 192.168.69.5/30\nrtr-01 # set private-key link_01_to_03\nrtr-01 # set port 7879\nrtr-01 # set description link_01_to_03\nrtr-01 # set peer rtr-02 allowed-ips 0.0.0.0/0\nrtr-01 # set peer rtr-02 pubkey <link_03_to_01 pubkey>\n\nrtr-01 # commit; save; exit\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[`Now SSH to the other routers and apply the \"same\" configuration, changing addresses, ports and keys. To streamline the task, you can use your preferred automation tool. I'm using `,(0,t.jsx)(e.a,{href:\"https://www.ansible.com\",children:\"Ansible\"}),\".\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Don't forget to allow the used ports on your firewall configuration.\"}),`\n`,(0,t.jsx)(e.p,{children:\"At this time, you should be able to ping other routers connected at the other end of the tunnels. If everything is working, we can get to the OSPF configuration.\"}),`\n`,(0,t.jsxs)(e.h2,{children:[\"A \",(0,t.jsx)(e.em,{children:\"sprinkle\"}),\" of OSPF\"]}),`\n`,(0,t.jsx)(e.p,{children:\"As we stated, we have to configure our interfaces to run OSPF In point-to-point mode. Get a shell onto your router and:\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`rtr-01 $ configure\nrtr-01 # edit interfaces wireguard wg01\nrtr-01 # set ip ospf network point-to-point\nrtr-01 # top\nrtr-01 # copy interfaces wireguard wg01 ip to interfaces wireguard wg02 ip\nrtr-01 # commit; save; exit\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"Follow the same steps on your other routers. Now we are at the fun part!\"}),`\n`,(0,t.jsx)(e.p,{children:\"We are adding the 0.0.0.0 area on every router, telling the OSPF daemon which point-to-point networks are part of this area, and telling what routes the router should redistribute to every other router.\"}),`\n`,(0,t.jsx)(e.p,{children:\"You know the drill, SSH to your favorite router first, and tell it what to do! Then, configure the other routers like this first one.\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`rtr-01 $ configure\nrtr-01 # edit protocols ospf area 0.0.0.0\nrtr-01 # set network 192.168.69.0/30\nrtr-01 # set network 192.168.69.4/30\nrtr-01 # set network 192.168.69.8/30\nrtr-01 # set redistribute connected\nrtr-01 # commit; save; exit\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"I'm not covering how to set up your firewall here since your configuration might be different than mine (I'm using zone-based firewall policies). Remember to accept traffic (from and to) the previously defined Wireguard interfaces.\"}),`\n`,(0,t.jsx)(e.h2,{children:\"Let's check if everything is in its place\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"At this point, everything should be working.\",(0,t.jsx)(e.br,{}),`\n`,\"Let's check:\"]}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsx)(e.li,{children:\"if the neighboring relationships are getting formed;\"}),`\n`,(0,t.jsx)(e.li,{children:\"if the link-state database is getting populated;\"}),`\n`,(0,t.jsx)(e.li,{children:\"if routes are getting injected into the routing table.\"}),`\n`]}),`\n`,(0,t.jsx)(e.h3,{children:\"Neighboring relationships\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`rtr-01 $ show ip ospf neighbor\n`})}),`\n`,(0,t.jsx)(e.h3,{children:\"Link-state database\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`rtr-01 $ show ip ospf database\n`})}),`\n`,(0,t.jsx)(e.h3,{children:\"Routes\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`rtr-01 $ show ip route ospf\n`})}),`\n`,(0,t.jsx)(e.h2,{children:\"Filtering routes\"}),`\n`,(0,t.jsx)(e.p,{children:`We can use a routing policy to filter the redistributed routes from our routers.\nA route map allows us to match a network or an interface (or an as-path, an extcommunity, a metric, a peer, a community, etc.).\nFor our purposes, we will permit the redistribution of networks attached to some interfaces.`}),`\n`,(0,t.jsx)(e.p,{children:\"Let's create a new policy:\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`rtr-01 $ configure\nrtr-01 # edit policy route-map FilteredRoutes\nrtr-01 # set rule 10 action permit\nrtr-01 # set rule 10 match interface eth1\nrtr-01 # commit\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"And now apply this policy to the redistribution configuration of the OSPF daemon:\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`rtr-01 # top\nrtr-01 # edit protocols ospf redistribute connected\nrtr-01 # set route-map FilteredRoutes\nrtr-01 # commit; save; exit\n`})}),`\n`,(0,t.jsx)(e.h2,{children:\"Bonus: (s)NAT\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Let's say you want to access a web server that sits in a network redistributed by \",(0,t.jsx)(e.code,{children:\"rtr-02\"}),\" from a client in a network attached to \",(0,t.jsx)(e.code,{children:\"rtr-01\"}),`, but we configured this router to don't redistribute that network.\nIn this case, SNAT is our friend. We are going to translate the source address of our client to the address of the interface connected to `,(0,t.jsx)(e.code,{children:\"rtr-02\"}),\".\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/posts/vyos-ospf-wireguard/netdiag2.svg\",alt:\"Network diagram\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Let's add this NAT rule to \",(0,t.jsx)(e.code,{children:\"rtr-01\"}),\".\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`rtr-01 $ configure\nrtr-01 # edit nat source\nrtr-01 # set rule 100 outbound-interface wg01\nrtr-01 # set rule 100 source address 192.168.16.0/24 # Change with your network.\nrtr-01 # commit; save; exit\n`})}),`\n`,(0,t.jsx)(e.h2,{children:\"Final checks\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Neighboring relationships\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`rtr-01 $ show ip ospf neighbor\n`})}),`\n`,(0,t.jsx)(e.h3,{children:\"Link-state database\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`rtr-01 $ show ip ospf database\n`})}),`\n`,(0,t.jsx)(e.h3,{children:\"Routes\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`rtr-01 $ show ip route ospf\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"You can see that the link state database and, consequently, the routing table are leaner than before since we have fewer routes advertised between our routers.\"}),`\n`,(0,t.jsx)(e.h2,{children:\"Conclusion\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/posts/vyos-ospf-wireguard/hello-from-your-ospf-neighbor.jpg\",alt:'An image of Adele the singer, with \"Hello from your OSPF neighbor\" superimposed'})}),`\n`,(0,t.jsxs)(e.p,{children:[\"And we are golden!\",(0,t.jsx)(e.br,{}),`\n`,\"Enjoy your brand new site-to-site VPN, and forget about adding static routes manually. OSPF will take care of that for you.\"]})]})}function v(r={}){let{wrapper:e}=r.components||{};return e?(0,t.jsx)(e,Object.assign({},r,{children:(0,t.jsx)(d,r)})):d(r)}var _=v;return k(S);})();\n;return Component;"
  },
  "_id": "blog/vyos-ospf-wireguard.md",
  "_raw": {
    "sourceFilePath": "blog/vyos-ospf-wireguard.md",
    "sourceFileName": "vyos-ospf-wireguard.md",
    "sourceFileDir": "blog",
    "contentType": "markdown",
    "flattenedPath": "blog/vyos-ospf-wireguard"
  },
  "type": "Post",
  "url": "blog/vyos-ospf-wireguard",
  "timeToRead": "6"
}